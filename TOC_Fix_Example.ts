/**
 * Company TOC Repair - Using Word's Native Heading References
 * 
 * SIMPLIFIED APPROACH:
 * Instead of manually creating bookmarks, use Word's built-in TOC field
 * that references Header 2 styles directly.
 * 
 * TOC Settings:
 * - Only Header 2 (no other levels)
 * - No title
 * - No page numbers
 * - Hyperlinks enabled
 */

import { Document, Paragraph } from 'docxmlater';
import { logger } from '@/utils/logger';

const log = logger.namespace('SimplifiedTOCRepair');

/**
 * Simplified TOC using Word's native heading references
 */
export class SimplifiedTOCRepair {
  
  /**
   * Main repair method
   */
  static async repairDocument(doc: Document): Promise<{
    tocGenerated: boolean;
    header2Count: number;
    topOfDocLinksAdded: number;
  }> {
    log.info('=== SIMPLIFIED TOC REPAIR STARTING ===');

    // Step 1: Find Header 1 (Title)
    const titleIndex = this.findHeader1Title(doc);
    log.info(`Header 1 found at paragraph ${titleIndex}`);

    // Step 2: Find all Header 2s in 1x1 tables
    const header2s = this.findHeader2InTables(doc);
    log.info(`Found ${header2s.length} Header 2 headings`);

    if (header2s.length === 0) {
      log.warn('No Header 2 headings found - skipping TOC');
      return {
        tocGenerated: false,
        header2Count: 0,
        topOfDocLinksAdded: 0,
      };
    }

    // Step 3: Generate TOC using Word's native field
    const tocGenerated = await this.generateNativeTOC(doc, titleIndex);

    // Step 4: Add "Top of Document" links
    const topOfDocLinksAdded = await this.ensureTopOfDocumentLinks(doc, header2s);

    // Step 5: Ensure "_top" bookmark for "Top of Document" links
    this.ensureTopBookmark(doc, titleIndex);

    log.info('=== SIMPLIFIED TOC REPAIR COMPLETE ===');
    log.info(`TOC ${tocGenerated ? 'generated' : 'verified'}`);
    log.info(`"Top of Document" links: ${topOfDocLinksAdded}`);

    return {
      tocGenerated,
      header2Count: header2s.length,
      topOfDocLinksAdded,
    };
  }

  /**
   * Generate TOC using Word's native TOC field
   * 
   * Word Field Code: { TOC \o "2-2" \h \z \t }
   * 
   * Switches:
   * - \o "2-2" = Only outline level 2 (Header 2)
   * - \h = Hyperlinks enabled
   * - \z = Hide tab leader
   * - \t = Use only specified styles
   */
  private static async generateNativeTOC(
    doc: Document,
    titleIndex: number
  ): Promise<boolean> {
    
    const tocPosition = titleIndex + 1;

    // Clear any existing TOC
    this.clearTOCSection(doc, tocPosition);

    // Create TOC field paragraph
    const tocField = this.createTOCFieldParagraph(doc);
    
    // Insert TOC after title
    this.insertParagraphAt(doc, tocField, tocPosition);

    // Add blank line after TOC
    const blankPara = this.createBlankParagraph(doc);
    this.insertParagraphAt(doc, blankPara, tocPosition + 1);

    log.info('Generated native TOC field');
    return true;
  }

  /**
   * Create TOC field paragraph
   * 
   * XML Structure:
   * <w:p>
   *   <w:pPr>
   *     <w:pStyle w:val="TOC1"/>
   *   </w:pPr>
   *   <w:fldSimple w:instr=" TOC \o &quot;2-2&quot; \h \z \t ">
   *     <!-- TOC content auto-generated by Word -->
   *   </w:fldSimple>
   * </w:p>
   */
  private static createTOCFieldParagraph(doc: Document): Paragraph {
    const para = doc.createParagraph();

    // Method 1: If docxmlater supports TOC field directly
    if (typeof (para as any).addTOCField === 'function') {
      (para as any).addTOCField({
        headingLevels: [2], // Only Header 2
        hyperlinks: true,
        pageNumbers: false,
        tabLeader: 'none',
      });
      return para;
    }

    // Method 2: Create field via XML
    const tocFieldXml = `
      <w:p>
        <w:pPr>
          <w:pStyle w:val="TOC1"/>
        </w:pPr>
        <w:fldSimple w:instr=" TOC \\o &quot;2-2&quot; \\h \\z \\t ">
          <w:r>
            <w:t>Right-click and select "Update Field" to generate TOC</w:t>
          </w:r>
        </w:fldSimple>
      </w:p>
    `;

    // Set XML if supported
    if (typeof (para as any).setXml === 'function') {
      (para as any).setXml(tocFieldXml);
    } else {
      // Fallback: Add instruction text
      para.addText('{ TOC \\o "2-2" \\h \\z \\t }');
      log.warn('TOC field created as text - may need manual update in Word');
    }

    return para;
  }

  /**
   * Alternative: Generate TOC entries as direct hyperlinks to Header 2 paragraphs
   * This avoids using TOC fields and creates simple hyperlinks
   */
  private static async generateSimpleHyperlinkTOC(
    doc: Document,
    titleIndex: number,
    header2s: any[]
  ): Promise<boolean> {
    
    const tocPosition = titleIndex + 1;

    // Clear existing TOC
    this.clearTOCSection(doc, tocPosition);

    // Create hyperlink for each Header 2
    for (let i = 0; i < header2s.length; i++) {
      const header = header2s[i];
      
      // Create TOC entry that links to Header 2 paragraph directly
      const tocEntry = this.createTOCHyperlinkEntry(
        doc,
        header.text,
        header.paragraphIndex
      );

      this.insertParagraphAt(doc, tocEntry, tocPosition + i);
      log.debug(`Created TOC hyperlink entry ${i + 1}: "${header.text}"`);
    }

    // Blank line after TOC
    const blankPara = this.createBlankParagraph(doc);
    this.insertParagraphAt(doc, blankPara, tocPosition + header2s.length);

    return true;
  }

  /**
   * Create TOC entry as hyperlink to Header 2 paragraph
   * Uses paragraph ID or creates minimal bookmark
   */
  private static createTOCHyperlinkEntry(
    doc: Document,
    text: string,
    targetParagraphIndex: number
  ): Paragraph {
    
    const para = doc.createParagraph();

    // Set formatting
    para.setAlignment('left');
    para.setSpacingBefore(3);
    para.setSpacingAfter(3);

    // Get target paragraph
    const paragraphs = doc.getParagraphs();
    const targetPara = paragraphs[targetParagraphIndex];

    // Option 1: Use paragraph ID if available
    const paraId = (targetPara as any).getId?.() || `_Ref${Date.now()}${targetParagraphIndex}`;

    // Create hyperlink
    const hyperlink = para.addHyperlink({
      anchor: paraId,
      text: text,
    });

    // Apply formatting
    hyperlink.setFont('Verdana');
    hyperlink.setFontSize(12);
    hyperlink.setUnderline(true);
    hyperlink.setColor('0000FF');

    // Ensure target paragraph has anchor/bookmark
    this.ensureParagraphAnchor(targetPara, paraId);

    return para;
  }

  /**
   * Ensure paragraph has an anchor/bookmark for hyperlinks to target
   */
  private static ensureParagraphAnchor(para: Paragraph, anchorId: string): void {
    // Check if paragraph already has bookmark
    const paraXml = this.getParagraphXml(para);
    
    if (paraXml.includes(`w:name="${anchorId}"`)) {
      return; // Already has bookmark
    }

    // Add minimal bookmark
    const bookmarkId = Math.floor(Math.random() * 1000000);
    
    let modifiedXml = paraXml.replace(
      /(<w:p[^>]*>)/,
      `$1<w:bookmarkStart w:id="${bookmarkId}" w:name="${anchorId}"/>`
    );
    
    modifiedXml = modifiedXml.replace(
      /(<\/w:p>)/,
      `<w:bookmarkEnd w:id="${bookmarkId}"/>$1`
    );

    if (typeof (para as any).setXml === 'function') {
      (para as any).setXml(modifiedXml);
    }
  }

  /**
   * Find Header 1 (Title)
   */
  private static findHeader1Title(doc: Document): number {
    const paragraphs = doc.getParagraphs();

    for (let i = 0; i < Math.min(10, paragraphs.length); i++) {
      const para = paragraphs[i];
      const styleName = para.getStyleName?.() || '';

      if (
        styleName === 'Heading1' ||
        styleName === 'Header1' ||
        styleName === 'Heading 1' ||
        styleName === 'Title' ||
        styleName === 'title'
      ) {
        return i;
      }
    }

    return 0;
  }

  /**
   * Find all Header 2s in 1x1 tables
   */
  private static findHeader2InTables(doc: Document): any[] {
    const header2s: any[] = [];
    const paragraphs = doc.getParagraphs();
    const tables = doc.getTables?.() || [];

    for (let tableIndex = 0; tableIndex < tables.length; tableIndex++) {
      const table = tables[tableIndex];
      const rows = table.getRows?.();
      
      if (!rows || rows.length !== 1) continue;

      const cells = rows[0].getCells?.();
      if (!cells || cells.length !== 1) continue;

      const cellParas = cells[0].getParagraphs?.() || [];

      for (const para of cellParas) {
        const styleName = para.getStyleName?.() || '';

        if (
          styleName === 'Heading2' ||
          styleName === 'Header2' ||
          styleName === 'Heading 2'
        ) {
          const text = para.getText().trim();
          if (!text) continue;

          const paragraphIndex = paragraphs.indexOf(para);

          header2s.push({
            paragraph: para,
            table,
            paragraphIndex,
            tableIndex,
            text,
          });
        }
      }
    }

    return header2s;
  }

  /**
   * Ensure "Top of Document" links
   */
  private static async ensureTopOfDocumentLinks(
    doc: Document,
    header2s: any[]
  ): Promise<number> {
    let linksAdded = 0;

    // Before 2nd Header 2 onwards
    for (let i = 1; i < header2s.length; i++) {
      const insertIndex = this.findInsertIndexBeforeTable(doc, header2s[i].tableIndex);
      
      if (!this.hasTopOfDocumentLink(doc, insertIndex)) {
        const topLink = this.createTopOfDocumentLink(doc);
        this.insertParagraphAt(doc, topLink, insertIndex);
        linksAdded++;
      }
    }

    // Last one before proprietary notice
    const lastIndex = this.findProprietaryNoticeIndex(doc);
    if (lastIndex > 0 && !this.hasTopOfDocumentLink(doc, lastIndex - 1)) {
      const topLink = this.createTopOfDocumentLink(doc);
      this.insertParagraphAt(doc, topLink, lastIndex);
      linksAdded++;
    }

    return linksAdded;
  }

  /**
   * Create "Top of Document" link
   */
  private static createTopOfDocumentLink(doc: Document): Paragraph {
    const para = doc.createParagraph();
    para.setAlignment('right');
    para.setSpacingBefore(3);
    para.setSpacingAfter(0);

    const hyperlink = para.addHyperlink({
      anchor: '_top',
      text: 'Top of Document',
    });

    hyperlink.setFont('Verdana');
    hyperlink.setFontSize(12);
    hyperlink.setUnderline(true);
    hyperlink.setColor('0000FF');

    return para;
  }

  /**
   * Ensure _top bookmark exists
   */
  private static ensureTopBookmark(doc: Document, titleIndex: number): void {
    const paragraphs = doc.getParagraphs();
    
    if (titleIndex + 1 < paragraphs.length) {
      this.ensureParagraphAnchor(paragraphs[titleIndex + 1], '_top');
    }
  }

  // Helper methods (same as before)
  private static clearTOCSection(doc: Document, startIndex: number): void {
    const paragraphs = doc.getParagraphs();
    let removed = 0;

    for (let i = startIndex; i < Math.min(startIndex + 30, paragraphs.length); i++) {
      const para = paragraphs[i];
      const content = para.getContent();

      let hasLink = false;
      for (const item of content) {
        if (item instanceof Hyperlink && item.getAnchor?.()) {
          hasLink = true;
          break;
        }
      }

      if (hasLink) {
        this.removeParagraphAt(doc, i - removed);
        removed++;
      } else {
        break;
      }
    }
  }

  private static hasTopOfDocumentLink(doc: Document, index: number): boolean {
    const paragraphs = doc.getParagraphs();
    if (index >= paragraphs.length) return false;

    const content = paragraphs[index].getContent();
    for (const item of content) {
      if (item instanceof Hyperlink) {
        const text = item.getText().trim().toLowerCase();
        if (text === 'top of document' || text === 'top of thedocument') {
          return true;
        }
      }
    }
    return false;
  }

  private static findProprietaryNoticeIndex(doc: Document): number {
    const paragraphs = doc.getParagraphs();
    const searchStart = Math.max(0, paragraphs.length - 20);

    for (let i = searchStart; i < paragraphs.length; i++) {
      const text = paragraphs[i].getText().toLowerCase();
      if (text.includes('proprietary') || text.includes('confidential')) {
        return i;
      }
    }

    return paragraphs.length;
  }

  private static findInsertIndexBeforeTable(doc: Document, tableIndex: number): number {
    // Simplified - you'll need to implement based on docxmlater API
    return tableIndex * 10; // Placeholder
  }

  private static createBlankParagraph(doc: Document): Paragraph {
    const para = doc.createParagraph();
    para.addText(' ');
    return para;
  }

  private static insertParagraphAt(doc: Document, para: Paragraph, index: number): void {
    if (typeof (doc as any).insertParagraph === 'function') {
      (doc as any).insertParagraph(para, index);
    } else {
      doc.addParagraph(para);
    }
  }

  private static removeParagraphAt(doc: Document, index: number): void {
    if (typeof (doc as any).removeParagraph === 'function') {
      (doc as any).removeParagraph(index);
    }
  }

  private static getParagraphXml(para: Paragraph): string {
    if (typeof (para as any).toXml === 'function') {
      return (para as any).toXml();
    }
    return '';
  }
}

/**
 * Main export - uses simplified approach
 */
export async function repairCompanyTOC(doc: Document): Promise<void> {
  const result = await SimplifiedTOCRepair.repairDocument(doc);
  
  log.info('═══════════════════════════════════════════════');
  log.info('  SIMPLIFIED TOC REPAIR COMPLETE');
  log.info('═══════════════════════════════════════════════');
  log.info(`Header 2 count: ${result.header2Count}`);
  log.info(`TOC ${result.tocGenerated ? 'generated' : 'verified'}`);
  log.info(`"Top of Document" links: ${result.topOfDocLinksAdded}`);
  log.info('═══════════════════════════════════════════════');
}
